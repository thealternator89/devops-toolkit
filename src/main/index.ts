import { app, BrowserWindow, ipcMain } from 'electron';
import * as azdev from 'azure-devops-node-api';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

interface AppSettings {
  azureOrg?: string;
  azureProject?: string;
  azurePat?: string;
  copilotToken?: string;
}

// Global store instance to be initialized dynamically
let store: any;

// Initialization helper for ESM dependencies in CJS
async function initStore() {
  if (!store) {
    const Store = (await import('electron-store')).default;
    store = new Store();
  }
  return store;
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// IPC Handlers
ipcMain.handle('get-settings', async () => {
  const s = await initStore();
  return s.get('settings');
});

ipcMain.handle('save-settings', async (event, settings: AppSettings) => {
  const s = await initStore();
  s.set('settings', settings);
  return { success: true };
});

ipcMain.handle('fetch-ticket', async (event, ticketId) => {
  const s = await initStore();
  const settings = s.get('settings') as AppSettings;
  if (!settings || !settings.azureOrg || !settings.azurePat) {
    throw new Error('Azure DevOps settings are missing.');
  }

  const authHandler = azdev.getPersonalAccessTokenHandler(settings.azurePat);
  const connection = new azdev.WebApi(settings.azureOrg, authHandler);
  const witApi = await connection.getWorkItemTrackingApi();
  
  try {
    const workItem = await witApi.getWorkItem(parseInt(ticketId));
    if (!workItem || !workItem.fields) {
      throw new Error('Work item not found.');
    }

    return {
      id: workItem.id,
      title: workItem.fields['System.Title'],
      description: workItem.fields['System.Description'],
      acceptanceCriteria: workItem.fields['Microsoft.VSTS.TCM.AcceptanceCriteria'],
      project: workItem.fields['System.TeamProject']
    };
  } catch (error) {
    console.error('Error fetching ticket:', error);
    throw error;
  }
});

ipcMain.handle('generate-test-cases', async (event, ticketData, additionalContext) => {
  // Dynamic import for Copilot SDK using eval to bypass Webpack bundling
  const { CopilotClient } = await eval('import("@github/copilot-sdk")');
  const client = new CopilotClient();
  
  try {
    // 1. Start the client and create a session
    await client.start();
    const session = await client.createSession();
    
    const prompt = `
      Generate a set of comprehensive test cases for the following user story/ticket.
      
      Ticket ID: ${ticketData.id}
      Title: ${ticketData.title}
      Description: ${ticketData.description}
      Acceptance Criteria: ${ticketData.acceptanceCriteria || 'N/A'}
      
      Additional Context: ${additionalContext || 'None provided'}
      
      Please format the output in a Markdown table, including:
      - Test Case ID
      - Description
      - Pre-conditions
      - Steps
      - Expected Result
      - Priority
    `;

    // 2. Send message and wait for assistant to finish
    const response = await session.sendAndWait({ prompt });
    const content = response?.data?.content || 'No content returned from Copilot.';

    // 3. Cleanup
    await session.destroy();
    await client.stop();

    return content;
  } catch (error) {
    console.error('Error generating test cases:', error);
    // Try to cleanup in case of failure
    try { await client.stop(); } catch (e) { /* ignore */ }
    throw error;
  }
});

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    titleBarStyle: 'hidden',
    titleBarOverlay: process.platform === 'win32' ? {
      color: '#212529',
      symbolColor: '#ffffff',
      height: 44
    } : false,
    trafficLightPosition: { x: 15, y: 15 }, // Adjusted for 44px height
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
